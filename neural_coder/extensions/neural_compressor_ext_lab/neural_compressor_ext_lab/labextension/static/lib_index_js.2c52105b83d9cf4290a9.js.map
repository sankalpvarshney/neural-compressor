{"version":3,"file":"lib_index_js.2c52105b83d9cf4290a9.js","mappings":"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AY,6EAA2B;AACvC;AACA,YAAY,gFAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mHAAmH,kBAAkB;AACrI;AACA;AACA;AACA,kHAAkH,kBAAkB;AACpI;AACA,wCAAwC,cAAc;AACtD,yBAAyB;AACzB,YAAY,4EAA+C;AAC3D,yCAAyC,cAAc,gGAAgG,kBAAkB;AACzK,0BAA0B;AAC1B,YAAY,4EAA+C;AAC3D,yCAAyC,cAAc;AACvD,0BAA0B;AAC1B,YAAY,4EAA+C;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtSwD;AACiB;AACV;AACd;AACG;AACX;AACqB;AACtB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uEAA+B;AACxE;AACA,wBAAwB,qEAA6B;AACrD;AACA,4BAA4B,0DAAkB;AAC9C;AACA;AACA;AACA;AACA,yBAAyB,qDAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAM;AAC1C;AACA;AACA;AACA;AACA;AACA,+BAA+B,mDAAM;AACrC;AACA;AACA,+BAA+B,+DAAa;AAC5C;AACA,sBAAsB,8DAAO;AAC7B;AACA,wBAAwB,0DAAkB;AAC1C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAU;AACpC;AACA;AACA,kCAAkC,iEAAe,GAAG,kBAAkB;AACtE,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAgB,EAAE,2DAAS;AAC1C,eAAe,yEAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;;;;ACxGtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AAC1D;AACiD;AAClB;AAChB;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAmB;AACnC,oBAAoB,gDAAmB,CAAC,2CAAc,IAAI,YAAY,EAAE,GAAG;AAC3E,gBAAgB,gDAAmB,CAAC,6DAAa,IAAI,qBAAqB,aAAa,gEAAgE;AACvJ,gBAAgB,gDAAmB;AACnC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAe,GAAG,gDAAgD;AAC9E;AACA;AACA,cAAc,gEAAU,GAAG,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAe,GAAG,mDAAmD;AACjF,YAAY,qEAAmB,GAAG,kDAAkD;AACpF;AACA;AACA,6BAA6B,gEAAU,GAAG,mCAAmC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa,kBAAkB,mBAAmB,aAAa;AAC/D,cAAc,kBAAkB,qBAAqB,aAAa;AAClE,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA,kGAAkG,YAAY,IAAI,IAAI,MAAM,IAAI;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://neural_compressor_ext_lab/./lib/constants.js","webpack://neural_compressor_ext_lab/./lib/deepcoder.js","webpack://neural_compressor_ext_lab/./lib/index.js","webpack://neural_compressor_ext_lab/./lib/utils.js"],"sourcesContent":["export var Constants;\n(function (Constants) {\n    Constants.SHORT_PLUGIN_NAME = 'neural_compressor_ext_lab';\n    Constants.WORK_PATH = \"neural_coder_workspace/\";\n    Constants.ICON_FORMAT_ALL_SVG = '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"margin: auto; background: rgb(255, 255, 255); display: block; shape-rendering: auto;\" width=\"53px\" height=\"53px\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"xMidYMid\"><circle cx=\"50\" cy=\"50\" r=\"32\" stroke-width=\"8\" stroke=\"#e15b64\" stroke-dasharray=\"50.26548245743669 50.26548245743669\" fill=\"none\" stroke-linecap=\"round\"><animateTransform attributeName=\"transform\" type=\"rotate\" dur=\"1s\" repeatCount=\"indefinite\" keyTimes=\"0;1\" values=\"0 50 50;360 50 50\"></animateTransform></circle><circle cx=\"50\" cy=\"50\" r=\"23\" stroke-width=\"8\" stroke=\"#f8b26a\" stroke-dasharray=\"36.12831551628262 36.12831551628262\" stroke-dashoffset=\"36.12831551628262\" fill=\"none\" stroke-linecap=\"round\"><animateTransform attributeName=\"transform\" type=\"rotate\" dur=\"1s\" repeatCount=\"indefinite\" keyTimes=\"0;1\" values=\"0 50 50;-360 50 50\"></animateTransform></circle></svg>';\n    Constants.ICON_RUN = '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\" version=\"1.1\" width=\"512\" height=\"512\" x=\"0\" y=\"0\" viewBox=\"0 0 24 24\" style=\"enable-background:new 0 0 512 512\" xml:space=\"preserve\" class=\"\"><g><g xmlns=\"http://www.w3.org/2000/svg\" clip-rule=\"evenodd\" fill=\"rgb(0,0,0)\" fill-rule=\"evenodd\"><path d=\"m3.09467 3.09467c1.33447-1.33447 3.33136-1.84467 5.90533-1.84467h6c2.574 0 4.5709.5102 5.9053 1.84467 1.3345 1.33447 1.8447 3.33136 1.8447 5.90533v6c0 2.574-.5102 4.5709-1.8447 5.9053-1.3344 1.3345-3.3313 1.8447-5.9053 1.8447h-6c-2.57397 0-4.57086-.5102-5.90533-1.8447-1.33447-1.3344-1.84467-3.3313-1.84467-5.9053v-2.05c0-.4142.33579-.75.75-.75s.75.3358.75.75v2.05c0 2.426.4898 3.9291 1.40533 4.8447.91553.9155 2.41864 1.4053 4.84467 1.4053h6c2.426 0 3.9291-.4898 4.8447-1.4053.9155-.9156 1.4053-2.4187 1.4053-4.8447v-6c0-2.42603-.4898-3.92914-1.4053-4.84467-.9156-.91553-2.4187-1.40533-4.8447-1.40533h-6c-2.42603 0-3.92914.4898-4.84467 1.40533s-1.40533 2.41864-1.40533 4.84467c0 .41421-.33579.75-.75.75s-.75-.33579-.75-.75c0-2.57397.5102-4.57086 1.84467-5.90533z\" fill=\"#505361\" data-original=\"#000000\" class=\"\"/><path d=\"m10.355 9.23276c-.2302.13229-.505.4923-.505 1.28724v2.96c0 .7885.2739 1.1502.5061 1.2841.2324.1342.6841.1907 1.3697-.2041.3589-.2066.8175-.0832 1.0242.2758.2066.3589.0832.8175-.2758 1.0242-.9644.5552-2.0127.6967-2.86779.2034-.85535-.4936-1.25641-1.4719-1.25641-2.5834v-2.96c0-1.11506.40022-2.09505 1.25754-2.58776.85596-.49195 1.90416-.34642 2.86666.20779l.0012.00067 2.5588 1.47933c-.0002-.00012.0002.00013 0 0 .9642.55537 1.6133 1.39217 1.6133 2.37997 0 .9881-.6487 1.8246-1.6133 2.38-.3589.2066-.8175.0832-1.0242-.2758-.2066-.3589-.0832-.8175.2758-1.0242.6854-.3946.8617-.8131.8617-1.08s-.1763-.6854-.8617-1.08l-2.56-1.48003c.0002.0001-.0002-.00011 0 0-.6871-.39546-1.1394-.34022-1.3708-.20721z\" fill=\"#505361\" data-original=\"#000000\" class=\"\"/></g></g></svg>';\n    Constants.SVG = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" viewBox=\"0 0 18 18\" data-icon=\"ui-components:caret-down-empty\"><g xmlns=\"http://www.w3.org/2000/svg\" class=\"jp-icon3\" fill=\"#616161\" shape-rendering=\"geometricPrecision\"><path d=\"M5.2,5.9L9,9.7l3.8-3.8l1.2,1.2l-4.9,5l-4.9-5L5.2,5.9z\"></path></g></svg>';\n    Constants.LONG_PLUGIN_NAME = `@rya/${Constants.SHORT_PLUGIN_NAME}`;\n    Constants.SETTINGS_SECTION = `${Constants.LONG_PLUGIN_NAME}:settings`;\n    Constants.COMMAND_SECTION_NAME = 'Jupyterlab Code Optimizer';\n    Constants.PLUGIN_VERSION = '0.1.0';\n})(Constants || (Constants = {}));\n","import { NotebookActions } from '@jupyterlab/notebook';\nimport NotebookUtilities from \"./utils\";\nimport { Constants } from './constants';\nclass JupyterlabCodeOptimizer {\n    constructor(panel) {\n        this.working = false;\n        this.panel = panel;\n        this.tmp_path = \"tmp.py\";\n        this.rand = NotebookUtilities.GetRandomNum(0, 200);\n        this.log_path = Constants.WORK_PATH + \"NeuralCoder\" + this.rand + \".log\";\n        this.tmp_log_path = Constants.WORK_PATH + \"NeuralCoder_tmp\" + \".log\";\n        this.cells = [];\n    }\n    async optimizeCode(code, formatter, name, next, options, notebook, panel, cell, run) {\n        let codes = [];\n        code.forEach(function (value) {\n            value = value.replace(/('\\\\n')/g, '^^^');\n            value = value.replace(/\\\\n\"/g, '###');\n            value = value.replace(/\\\\n'/g, '###');\n            value = value.replace(/\"\\\\n/g, '@@');\n            value = value.replace(/'\\\\n/g, '@@');\n            value = value.replace(/\\n/g, '\\\\n');\n            value = value.replace(/\"/g, '+++');\n            value = value.replace(/,/g, '$');\n            codes.push(value);\n        });\n        let gen_code = `code = \"${codes}\"\\ncodes = code.split(',')\\nwith open( '${this.tmp_path}', 'w+' ) as f:\\n    for i in range(0,len(codes)):\\n        f.write('# this is the beginning of a single code snippet\\\\n')\\n        code_list = codes[i].replace('$',',').replace('+++','\\\"').split('\\\\n')\\n        for line in code_list:\\n            if('split(^^^)' in line):\\n                    line=line.replace('split(^^^)', 'split(\\\\'\\\\\\\\n\\\\')')\\n            if('###' in line):\\n                    line=line.replace('###', '\\\\\\\\n\\\"')\\n            if('@@' in line):\\n                    line=line.replace('@@', '\\\"\\\\\\\\n')\\n            f.write(line+'\\\\n')`;\n        const expr = { code_list: `code_list` };\n        NotebookUtilities.sendKernelRequestFromNotebook(panel, gen_code, expr, false);\n        if (options === 'normal') {\n            let runcode = `from neural_coder import enable\\nenable(code=\"${this.tmp_path}\",features=[\"${formatter}\"], overwrite=True)`;\n            let expr = { sum: ` ` };\n            NotebookUtilities.sendKernelRequestFromNotebook(panel, runcode, expr, false);\n            let run_code1 = `with open(\"${this.tmp_path}\", 'r') as f:\\n    optimized_code = f.read()\\n`;\n            let expr1 = { optimizedCode: \"optimized_code\" };\n            let result2 = NotebookUtilities.sendKernelRequestFromNotebook(panel, run_code1, expr1, false);\n            result2.then(value => {\n                var _a, _b, _c, _d;\n                let optimizedTexts = Object.values(value.optimizedCode.data)[0];\n                let optimizeCodes = optimizedTexts.split('# this is the beginning of a single code snippet\\\\n').slice(1);\n                optimizeCodes[optimizeCodes.length - 1] = optimizeCodes[optimizeCodes.length - 1].slice(0, -3);\n                for (let i = 0; i < optimizeCodes.length; ++i) {\n                    const cell = this.cells[i];\n                    const currentTexts = this.cells.map(cell => cell.model.value.text);\n                    const currentText = currentTexts[i];\n                    let optimizedtext = optimizeCodes[i];\n                    optimizedtext = optimizedtext.replace(/\\\\'\\\\\\\\n\\\\'/g, \"^^^\");\n                    optimizedtext = optimizedtext.replace(/\\\\\\\\n\"/g, \"+++\");\n                    optimizedtext = optimizedtext.replace(/\\\\\\\\n'/g, \"+++\");\n                    optimizedtext = optimizedtext.replace(/\"\\\\\\\\n/g, \"@@@\");\n                    optimizedtext = optimizedtext.replace(/'\\\\\\\\n/g, \"@@@\");\n                    optimizedtext = optimizedtext.replace(/\\\\n/g, '\\n');\n                    optimizedtext = optimizedtext.replace(/\\\\'/g, \"'\");\n                    optimizedtext = optimizedtext.replace(/\\^\\^\\^/g, \"'\\\\n'\");\n                    optimizedtext = optimizedtext.replace(/\\+\\+\\+/g, \"\\\\n\\\"\");\n                    optimizedtext = optimizedtext.replace(/\\@\\@\\@/g, \"\\\"\\\\n\");\n                    if (cell.model.value.text === currentText) {\n                        cell.model.value.text = optimizedtext;\n                    }\n                    const run_svg = document.createElement(\"svg\");\n                    run_svg.innerHTML = Constants.ICON_RUN;\n                    (_d = (_c = (_b = (_a = run === null || run === void 0 ? void 0 : run.node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild) === null || _b === void 0 ? void 0 : _b.firstChild) === null || _c === void 0 ? void 0 : _c.firstChild) === null || _d === void 0 ? void 0 : _d.replaceWith(run_svg);\n                }\n            });\n        }\n        else {\n            if (formatter === '') {\n                if (this.markdown) {\n                    this.markdown.model.value.text += \"[NeuralCoder INFO] Enabling and Benchmarking for The Original Model ......  \\n\";\n                }\n                // cell.outputArea.node.innerText += \"[NeuralCoder INFO] Enabling and Benchmarking for The Original Model ......\\n\"\n                let runcode1 = `with open(\"${this.log_path}\", 'a' ) as f:\\n       f.write(\"[NeuralCoder INFO] Enabling and Benchmarking for The Original Model ......\\\\n\")`;\n                let expr1 = { path: \"\" };\n                NotebookUtilities.sendKernelRequestFromNotebook(panel, runcode1, expr1, false);\n                let runcode = `from neural_coder import enable\\nperfomance, mode, path = enable(code=\"${this.tmp_path}\",features=[], run_bench=True, args=\"${options}\")\\nwith open(path + '/bench.log', 'r') as f:\\n    logs = f.readlines()\\nlog_line = logs[4]\\nlog = log_line.split(\"[\")[1].split(\"]\")[0]`;\n                let expr = { path: \"path\", log: \"log\" };\n                let result = NotebookUtilities.sendKernelRequestFromNotebook(panel, runcode, expr, false);\n                let fps;\n                result.then(value => {\n                    fps = Object.values(value.log.data)[0];\n                    if (this.markdown) {\n                        this.markdown.model.value.text += `[NeuralCoder INFO] Benchmark Result (Performance) of The Original Model is ${fps} (samples/second)  \\n`;\n                    }\n                    // cell.outputArea.node.innerText += `[NeuralCoder INFO] Benchmark Result (Performance) of The Original Model is ${fps} (samples/second)\\n`\n                    let text = `[NeuralCoder INFO] Benchmark Result (Performance) of The Original Model is ${fps} (samples/second)\\\\n`;\n                    let runcode = `with open(\"${this.log_path}\", 'a' ) as f:\\n   f.write(\"${text}\")`;\n                    let expr = { path: \"\" };\n                    NotebookUtilities.sendKernelRequestFromNotebook(this.panel, runcode, expr, false);\n                    if (this.markdown) {\n                        this.markdown.model.value.text += `[NeuralCoder INFO] Enabling and Benchmarking for ${next} ......  \\n`;\n                    }\n                    // cell.outputArea.node.innerText += `[NeuralCoder INFO] Enabling and Benchmarking for ${next} ......\\n`\n                    let runcode1 = `with open(\"${this.log_path}\", 'a' ) as f:\\n       f.write(\"[NeuralCoder INFO] Enabling and Benchmarking for ${next} ......\\\\n\")`;\n                    let expr1 = { path: \"\" };\n                    NotebookUtilities.sendKernelRequestFromNotebook(panel, runcode1, expr1, false);\n                    let runcode2 = `with open(\"${this.tmp_log_path}\", 'a' ) as f:\\n       f.write(\"${text}\")`;\n                    let expr2 = { path: \"\" };\n                    NotebookUtilities.sendKernelRequestFromNotebook(this.panel, runcode2, expr2, false);\n                });\n            }\n            else {\n                let runcode = `from neural_coder import enable\\nperfomance, mode, path = enable(code=\"${this.tmp_path}\", features=[\"${formatter}\"], run_bench=True, args=\"${options}\")\\nwith open(path + '/bench.log', 'r') as f:\\n    logs = f.readlines()\\nlog_line = logs[4]\\nlog = log_line.split(\"[\")[1].split(\"]\")[0]`;\n                let expr = { path: \"path\", log: \"log\" };\n                let result = NotebookUtilities.sendKernelRequestFromNotebook(panel, runcode, expr, false);\n                let fps;\n                result.then(value => {\n                    fps = Object.values(value.log.data)[0];\n                    if (this.markdown) {\n                        this.markdown.model.value.text += `[NeuralCoder INFO] Benchmark Result (Performance) of ${name} is ${fps} (samples/second)  \\n`;\n                    }\n                    // cell.outputArea.node.innerText += `[NeuralCoder INFO] Benchmark Result (Performance) of ${name} is ${fps} (FPS)\\n`\n                    let text = `[NeuralCoder INFO] Benchmark Result (Performance) of ${name} is ${fps} (samples/second)\\\\n`;\n                    let runcode = `with open(\"${this.log_path}\", 'a' ) as f:\\n       f.write(\"${text}\")`;\n                    let expr = { path: \"\" };\n                    NotebookUtilities.sendKernelRequestFromNotebook(this.panel, runcode, expr, false);\n                    if (next !== '') {\n                        if (this.markdown) {\n                            this.markdown.model.value.text += `[NeuralCoder INFO] Enabling and Benchmarking for ${next} ......  \\n`;\n                        }\n                        // cell.outputArea.node.innerText += `[NeuralCoder INFO] Enabling and Benchmarking for ${next} ......\\n`\n                        let runcode2 = `with open(\"${this.log_path}\", 'a' ) as f:\\n       f.write(\"[NeuralCoder INFO] Enabling and Benchmarking for ${next} ......\\\\n\")`;\n                        let expr2 = { path: \"\" };\n                        NotebookUtilities.sendKernelRequestFromNotebook(this.panel, runcode2, expr2, false);\n                    }\n                    let runcode3 = `with open(\"${this.tmp_log_path}\", 'a' ) as f:\\n       f.write(\"${text}\")`;\n                    let expr3 = { path: \"\" };\n                    let res_tmp = NotebookUtilities.sendKernelRequestFromNotebook(this.panel, runcode3, expr3, false);\n                    res_tmp.then(value => {\n                        if (formatter === 'pytorch_inc_bf16') {\n                            let read_log = `import re\\nwith open(\"${this.tmp_log_path}\", 'r') as f:\\n    logs = f.readlines()\\n    fps_list=[]\\n    for log_line in logs[-4:]:\\n        pat = re.compile(r\\'\\\\d+\\\\.?\\\\d+')\\n        fps = re.findall(pat,log_line)[-1]\\n        fps_list.append(float(fps))\\nmaxi = max(fps_list)\\nindex = fps_list.index(maxi)\\nboost = round(maxi/fps_list[0],1)\\nfeatures=['','pytorch_inc_static_quant_fx','pytorch_inc_dynamic_quant','pytorch_inc_bf16']\\nfeature_name=['Original Model','INC Enable INT8 (Static)','INC Enable INT8 (Dynamic)','INC Enable BF16']\\nbest_feature = features[index]\\nbest_name = feature_name[index]\\nfeature_l = []\\nfeature_l.append(best_feature)\\nfrom neural_coder import enable\\nenable(code=\"${this.tmp_path}\",features=feature_l, overwrite=True)\\nwith open(\"${this.tmp_path}\", 'r') as f:\\n    optimized_code = f.read()\\n`;\n                            let read_expr = { boost: \"boost\", best_feature: \"best_feature\", best_name: \"best_name\", optimizeCode: \"optimized_code\", feature_l: \"fps_list\", maxi: \"maxi\", index: \"index\" };\n                            let read_result = NotebookUtilities.sendKernelRequestFromNotebook(this.panel, read_log, read_expr, false);\n                            read_result.then(value => {\n                                var _a, _b, _c, _d;\n                                console.log(\"resres\", value);\n                                let boost = Object.values(value.boost.data)[0];\n                                let best_name = Object.values(value.best_name.data)[0];\n                                let optimizedTexts = Object.values(value.optimizeCode.data)[0];\n                                let optimizeCodes = optimizedTexts.split('# this is the beginning of a single code snippet\\\\n').slice(1);\n                                if (this.markdown) {\n                                    this.markdown.model.value.text += `[NeuralCoder INFO] The Best Intel Optimization: ${best_name}  \\n`;\n                                    this.markdown.model.value.text += `[NeuralCoder INFO] You can get up to ${boost}X performance boost.  \\n`;\n                                }\n                                // cell.outputArea.node.innerText +=`[NeuralCoder INFO] The Best Intel Optimization: ${best_name}\\n`\n                                // cell.outputArea.node.innerText += `[NeuralCoder INFO] You can get up to ${boost}X performance boost.\\n`\n                                optimizeCodes[optimizeCodes.length - 1] = optimizeCodes[optimizeCodes.length - 1].slice(0, -3);\n                                for (let i = 0; i < optimizeCodes.length; ++i) {\n                                    const cell = this.cells[i];\n                                    const currentTexts = this.cells.map(cell => cell.model.value.text);\n                                    const currentText = currentTexts[i];\n                                    let optimizedtext = optimizeCodes[i];\n                                    optimizedtext = optimizedtext.replace(/\\\\'\\\\\\\\n\\\\'/g, \"^^^\");\n                                    optimizedtext = optimizedtext.replace(/\\\\\\\\n\"/g, \"+++\");\n                                    optimizedtext = optimizedtext.replace(/\\\\\\\\n'/g, \"+++\");\n                                    optimizedtext = optimizedtext.replace(/\"\\\\\\\\n/g, \"@@@\");\n                                    optimizedtext = optimizedtext.replace(/'\\\\\\\\n/g, \"@@@\");\n                                    optimizedtext = optimizedtext.replace(/\\\\n/g, '\\n');\n                                    optimizedtext = optimizedtext.replace(/\\\\'/g, \"'\");\n                                    optimizedtext = optimizedtext.replace(/\\^\\^\\^/g, \"'\\\\n'\");\n                                    optimizedtext = optimizedtext.replace(/\\+\\+\\+/g, \"\\\\n\\\"\");\n                                    optimizedtext = optimizedtext.replace(/\\@\\@\\@/g, \"\\\"\\\\n\");\n                                    if (cell.model.value.text === currentText) {\n                                        cell.model.value.text = optimizedtext;\n                                    }\n                                }\n                                // if(this.markdown){\n                                //       this.markdown.model.value.text += `[NeuralCoder INFO] HardWare: 4th Gen Intel Xeon Scalable processor with AMX \\n`\n                                //       this.markdown.model.value.text += `[NeuralCoder INFO] The log was saved to neural_coder_workspace\\\\NeuralCoder${this.rand}.log  \\n`\n                                //     }\n                                let command = \"lscpu | grep 'Model name'\";\n                                let get_hardware = `import subprocess\\nsubp = subprocess.Popen(\"${command}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE,encoding=\"utf-8\")\\nsubp.wait(2)\\nhardware = subp.communicate()[0].replace(\"Model name:\",\"\").strip()`;\n                                let expr_hardware = { hardware: \"hardware\" };\n                                let hard_res = NotebookUtilities.sendKernelRequestFromNotebook(this.panel, get_hardware, expr_hardware, false);\n                                hard_res.then(value => {\n                                    let hard = Object.values(value.hardware.data)[0];\n                                    if (this.markdown) {\n                                        this.markdown.model.value.text += `[NeuralCoder INFO] HardWare: ${hard}  \\n`;\n                                        this.markdown.model.value.text += `[NeuralCoder INFO] The log was saved to neural_coder_workspace\\\\NeuralCoder${this.rand}.log  \\n`;\n                                    }\n                                    cell.outputArea.node.innerText += `[NeuralCoder INFO] HardWare: ${hard}\\n`;\n                                });\n                                cell.outputArea.node.innerText += `[NeuralCoder INFO] The log was saved to neural_coder_workspace\\\\NeuralCoder${this.rand}.log\\n`;\n                                const run_svg = document.createElement(\"svg\");\n                                run_svg.innerHTML = Constants.ICON_RUN;\n                                (_d = (_c = (_b = (_a = run === null || run === void 0 ? void 0 : run.node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild) === null || _b === void 0 ? void 0 : _b.firstChild) === null || _c === void 0 ? void 0 : _c.firstChild) === null || _d === void 0 ? void 0 : _d.replaceWith(run_svg);\n                            });\n                        }\n                    });\n                });\n            }\n        }\n    }\n}\nexport class JupyterlabNotebookCodeOptimizer extends JupyterlabCodeOptimizer {\n    constructor(notebookTracker, panel) {\n        super(panel);\n        this.notebookTracker = notebookTracker;\n        this.notebookname = '';\n    }\n    async optimizeAction(config, formatter) {\n        return this.optimizeCells(true, config, formatter);\n    }\n    async optimizeAllCodeCells(config, formatter, notebook, run) {\n        return this.optimizeCells(false, config, formatter, notebook, run);\n    }\n    getCodeCells(ifmarkdown = true, notebook) {\n        if (!this.notebookTracker.currentWidget) {\n            return [];\n        }\n        const codeCells = [];\n        notebook = notebook || this.notebookTracker.currentWidget.content;\n        this.notebookname = notebook.title.label;\n        let count = 0;\n        notebook.widgets.forEach((cell) => {\n            if (cell.model.type === 'code') {\n                count += 1;\n                codeCells.push(cell);\n            }\n        });\n        if (ifmarkdown) {\n            NotebookActions.insertBelow(notebook);\n            this.notebookTracker.currentWidget.content.activeCellIndex = count + 1;\n            NotebookActions.changeCellType(notebook, 'markdown');\n            const activeCell = notebook.activeCell;\n            if (activeCell) {\n                this.markdown = activeCell;\n            }\n        }\n        this.cells = codeCells;\n        return codeCells;\n    }\n    async optimizeCells(selectedOnly, config, formatter, notebook, run) {\n        if (this.working) {\n            return new Promise((resolve, reject) => {\n                resolve(\"false!\");\n            });\n        }\n        console.log(\"arrive here 333\");\n        this.working = true;\n        const optimize_type = formatter !== undefined ? formatter : 'pytorch_mixed_precision_cpu';\n        if (optimize_type === 'auto-quant') {\n            selectedOnly = true;\n        }\n        else {\n            selectedOnly = false;\n        }\n        const selectedCells = this.getCodeCells(selectedOnly, notebook);\n        let cell = selectedCells[selectedCells.length - 1];\n        if (selectedCells.length === 0) {\n            this.working = false;\n            return new Promise((resolve, reject) => {\n                resolve(\"false!\");\n            });\n        }\n        const currentTexts = selectedCells.map(cell => cell.model.value.text);\n        if (optimize_type === 'auto-quant') {\n            console.log(\"arrive here 444-111\");\n            if (this.markdown) {\n                this.markdown.model.value.text = `[NeuralCoder INFO] Auto-Quant Started ......  \\n`;\n                this.markdown.model.value.text += `[NeuralCoder INFO] Code: User code from Jupyter Lab notebook \"${this.notebookname}\"  \\n`;\n                this.markdown.model.value.text += `[NeuralCoder INFO] Benchmark Mode: Throughput  \\n`;\n            }\n            // cell.outputArea.node.innerText = `[NeuralCoder INFO] Auto-Quant Started ......\\n`\n            // cell.outputArea.node.innerText += `[NeuralCoder INFO] Code: User code from Jupyter Lab notebook \"${this.notebookname}\"\\n`\n            // cell.outputArea.node.innerText += `[NeuralCoder INFO] Benchmark Mode: Throughput\\n`\n            let runcode = `with open('${this.log_path}', 'a' ) as f:\\n       f.write(\"[NeuralCoder INFO] Auto-Quant Started ......\\\\n\")`;\n            let expr = { path: \"\" };\n            NotebookUtilities.sendKernelRequestFromNotebook(this.panel, runcode, expr, false);\n            let runcode2 = `with open('${this.log_path}', 'a' ) as f:\\n       f.write(\"[NeuralCoder INFO] Code: User code from Jupyter Lab notebook '${this.notebookname}'\\\\n\")`;\n            let expr2 = { path: \"\" };\n            NotebookUtilities.sendKernelRequestFromNotebook(this.panel, runcode2, expr2, false);\n            let runcode3 = `with open('${this.log_path}', 'a' ) as f:\\n       f.write(\"[NeuralCoder INFO] Benchmark Mode: Throughput\\\\n\")`;\n            let expr3 = { path: \"\" };\n            NotebookUtilities.sendKernelRequestFromNotebook(this.panel, runcode3, expr3, false);\n            // cell.outputArea.node.setAttribute(\"class\",\"pad\")\n            await this.optimizeCode(currentTexts, '', 'The Original Model', 'INC Enable INT8 (Static)', config, true, this.panel, cell, run);\n            await this.optimizeCode(currentTexts, 'pytorch_inc_static_quant_fx', 'INC Enable INT8 (Static)', 'INC Enable INT8 (Dynamic)', config, true, this.panel, cell, run);\n            await this.optimizeCode(currentTexts, 'pytorch_inc_dynamic_quant', 'INC Enable INT8 (Dynamic)', 'INC Enable BF16', config, true, this.panel, cell, run);\n            await this.optimizeCode(currentTexts, 'pytorch_inc_bf16', 'INC Enable BF16', '', config, true, this.panel, cell, run);\n        }\n        else {\n            console.log(\"arrive here 444-222\");\n            await this.optimizeCode(currentTexts, optimize_type, \"\", \"\", \"normal\", true, this.panel, cell, run);\n        }\n        this.working = false;\n        console.log(\"arrive here 555\");\n        return new Promise((resolve, reject) => {\n            resolve(\"success!\");\n        });\n    }\n    applicable(formatter, currentWidget) {\n        const currentNotebookWidget = this.notebookTracker.currentWidget;\n        return currentNotebookWidget && currentWidget === currentNotebookWidget;\n    }\n}\n","import { INotebookTracker } from '@jupyterlab/notebook';\nimport { ToolbarButton, showDialog, Dialog } from '@jupyterlab/apputils';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { IMainMenu } from '@jupyterlab/mainmenu';\nimport { LabIcon } from '@jupyterlab/ui-components';\nimport { Widget } from '@lumino/widgets';\nimport { JupyterlabNotebookCodeOptimizer } from './deepcoder';\nimport { Constants } from './constants';\nclass neural_compressor_ext_lab {\n    constructor(app, tracker, notebookpanel) {\n        this.app = app;\n        this.tracker = tracker;\n        this.notebookpanel = notebookpanel;\n        this.setupWidgetExtension();\n        this.config = '';\n    }\n    createNew(nb) {\n        this.notebookpanel = nb;\n        this.notebookCodeOptimizer = new JupyterlabNotebookCodeOptimizer(this.tracker, this.notebookpanel);\n        const svg = document.createElement(\"svg\");\n        svg.innerHTML = Constants.ICON_FORMAT_ALL_SVG;\n        const run_svg = document.createElement(\"svg\");\n        run_svg.innerHTML = Constants.ICON_RUN;\n        const div = document.createElement(\"div\");\n        div.setAttribute(\"class\", \"wrapper\");\n        const span = document.createElement(\"span\");\n        span.setAttribute(\"class\", \"f1ozlkqi\");\n        span.innerHTML = Constants.SVG;\n        const selector = document.createElement(\"select\");\n        selector.setAttribute(\"class\", \"aselector\");\n        selector.id = \"NeuralCoder\";\n        const option1 = document.createElement(\"option\");\n        option1.value = \"pytorch_inc_static_quant_fx\";\n        option1.innerText = \"INC Enable INT8 (Static)\";\n        option1.selected = true;\n        const option2 = document.createElement(\"option\");\n        option2.value = \"pytorch_inc_dynamic_quant\";\n        option2.innerText = \"INC Enable INT8 (Dynamic)\";\n        const option3 = document.createElement(\"option\");\n        option3.value = \"pytorch_inc_bf16\";\n        option3.innerText = \"INC Enable BF16\";\n        const option4 = document.createElement(\"option\");\n        option4.value = \"auto-quant\";\n        option4.innerText = \"INC Auto Enable & Benchmark\";\n        selector.options.add(option1);\n        selector.options.add(option2);\n        selector.options.add(option3);\n        selector.options.add(option4);\n        div.appendChild(selector);\n        div.appendChild(span);\n        const selector_widget = new Widget();\n        selector_widget.node.appendChild(div);\n        selector_widget.addClass(\"aselector\");\n        let notebookCodeOptimizer = this.notebookCodeOptimizer;\n        let config = this.config;\n        const dia_input = document.createElement(\"input\");\n        const dia_widget = new Widget();\n        dia_widget.node.appendChild(dia_input);\n        dia_widget.addClass(\"dialog\");\n        const run_button = new ToolbarButton({\n            tooltip: 'NeuralCoder',\n            icon: new LabIcon({\n                name: \"run\",\n                svgstr: Constants.ICON_RUN\n            }),\n            onClick: async function () {\n                var _a, _b, _c, _d;\n                console.log(\"arrive here 111\");\n                (_d = (_c = (_b = (_a = run_button.node.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild) === null || _b === void 0 ? void 0 : _b.firstChild) === null || _c === void 0 ? void 0 : _c.firstChild) === null || _d === void 0 ? void 0 : _d.replaceWith(svg);\n                if (selector.options[selector.selectedIndex].value === 'auto-quant') {\n                    await showDialog({\n                        title: 'Please input execute parameters:',\n                        body: dia_widget,\n                        buttons: [Dialog.okButton({ label: 'Confirm' })]\n                    }).then(result => {\n                        if (result.button.accept) {\n                            config = dia_input.value;\n                        }\n                    });\n                }\n                console.log(\"arrive here 222\");\n                await notebookCodeOptimizer.optimizeAllCodeCells(config, selector.options[selector.selectedIndex].value, undefined, run_button);\n            }\n        });\n        nb.toolbar.insertItem(11, \"nc\", run_button);\n        nb.toolbar.insertItem(12, \"selector\", selector_widget);\n    }\n    setupWidgetExtension() {\n        this.app.docRegistry.addWidgetExtension('Notebook', this);\n    }\n}\n/**\n * Initialization data for the neural_compressor_ext_lab extension.\n */\nconst plugin = {\n    id: 'neural_compressor_ext_lab:plugin',\n    autoStart: true,\n    requires: [INotebookTracker, IMainMenu],\n    optional: [ISettingRegistry],\n    activate: (app, tracker, notebookpanel) => {\n        new neural_compressor_ext_lab(app, tracker, notebookpanel);\n        console.log('JupyterLab extension neural_compressor_ext_lab is activated!');\n    }\n};\nexport default plugin;\n","/*\n * Copyright 2019-2020 The Kale Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Dialog, showDialog } from '@jupyterlab/apputils';\n// @ts-ignore\nimport SanitizedHTML from 'react-sanitized-html';\nimport * as React from 'react';\nexport default class NotebookUtilities {\n    /**\n      * generate random number\n      * @Min\n      * @Max\n      */\n    static GetRandomNum(Min, Max) {\n        let Range;\n        Range = Max - Min;\n        var Rand = Math.random();\n        return (Min + Math.round(Rand * Range));\n    }\n    /**\n     * Builds an HTML container by sanitizing a list of strings and converting\n     * them in valid HTML\n     * @param msg A list of string with HTML formatting\n     * @returns a HTMLDivElement composed of a list of spans with formatted text\n     */\n    static buildDialogBody(msg) {\n        return (React.createElement(\"div\", null, msg.map((s, i) => {\n            return (React.createElement(React.Fragment, { key: `msg-${i}` },\n                React.createElement(SanitizedHTML, { allowedAttributes: { a: ['href'] }, allowedTags: ['b', 'i', 'em', 'strong', 'a', 'pre'], html: s }),\n                React.createElement(\"br\", null)));\n        })));\n    }\n    /**\n     * Opens a pop-up dialog in JupyterLab to display a simple message.\n     * @param title The title for the message popup\n     * @param msg The message as an array of strings\n     * @param buttonLabel The label to use for the button. Default is 'OK'\n     * @param buttonClassName The classname to give to the 'ok' button\n     * @returns Promise<void> - A promise once the message is closed.\n     */\n    static async showMessage(title, msg, buttonLabel = 'Dismiss', buttonClassName = '') {\n        const buttons = [\n            Dialog.okButton({ label: buttonLabel, className: buttonClassName }),\n        ];\n        const messageBody = this.buildDialogBody(msg);\n        await showDialog({ title, buttons, body: messageBody });\n    }\n    /**\n     * Opens a pop-up dialog in JupyterLab to display a yes/no dialog.\n     * @param title The title for the message popup\n     * @param msg The message\n     * @param acceptLabel The label to use for the accept button. Default is 'YES'\n     * @param rejectLabel The label to use for the reject button. Default is 'NO'\n     * @param yesButtonClassName The classname to give to the accept button.\n     * @param noButtonClassName The  classname to give to the cancel button.\n     * @returns Promise<void> - A promise once the message is closed.\n     */\n    static async showYesNoDialog(title, msg, acceptLabel = 'YES', rejectLabel = 'NO', yesButtonClassName = '', noButtonClassName = '') {\n        const buttons = [\n            Dialog.okButton({ label: acceptLabel, className: yesButtonClassName }),\n            Dialog.cancelButton({ label: rejectLabel, className: noButtonClassName }),\n        ];\n        const messageBody = this.buildDialogBody(msg);\n        const result = await showDialog({ title, buttons, body: messageBody });\n        return result.button.label === acceptLabel;\n    }\n    /**\n     * Opens a pop-up dialog in JupyterLab with various information and button\n     * triggering reloading the page.\n     * @param title The title for the message popup\n     * @param msg The message\n     * @param buttonLabel The label to use for the button. Default is 'Refresh'\n     * @param buttonClassName The  classname to give to the 'refresh' button.\n     * @returns Promise<void> - A promise once the message is closed.\n     */\n    static async showRefreshDialog(title, msg, buttonLabel = 'Refresh', buttonClassName = '') {\n        await this.showMessage(title, msg, buttonLabel, buttonClassName);\n        location.reload();\n    }\n    /**\n     * @description Creates a new JupyterLab notebook for use by the application\n     * @param command The command registry\n     * @returns Promise<NotebookPanel> - A promise containing the notebook panel object that was created (if successful).\n     */\n    static async createNewNotebook(command) {\n        const notebook = await command.execute('notebook:create-new', {\n            activate: true,\n            path: '',\n            preferredLanguage: '',\n        });\n        await notebook.session.ready;\n        return notebook;\n    }\n    /**\n     * Safely saves the Jupyter notebook document contents to disk\n     * @param notebookPanel The notebook panel containing the notebook to save\n     */\n    static async saveNotebook(notebookPanel) {\n        if (notebookPanel) {\n            await notebookPanel.context.ready;\n            notebookPanel.context.save();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Convert the notebook contents to JSON\n     * @param notebookPanel The notebook panel containing the notebook to serialize\n     */\n    static notebookToJSON(notebookPanel) {\n        if (notebookPanel.content.model) {\n            return notebookPanel.content.model.toJSON();\n        }\n        return null;\n    }\n    /**\n     * @description Gets the value of a key from specified notebook's metadata.\n     * @param notebookPanel The notebook to get meta data from.\n     * @param key The key of the value.\n     * @returns any -The value of the metadata. Returns null if the key doesn't exist.\n     */\n    static getMetaData(notebookPanel, key) {\n        if (!notebookPanel) {\n            throw new Error('The notebook is null or undefined. No meta data available.');\n        }\n        if (notebookPanel.model && notebookPanel.model.metadata.has(key)) {\n            return notebookPanel.model.metadata.get(key);\n        }\n        return null;\n    }\n    /**\n     * @description Sets the key value pair in the notebook's metadata.\n     * If the key doesn't exists it will add one.\n     * @param notebookPanel The notebook to set meta data in.\n     * @param key The key of the value to create.\n     * @param value The value to set.\n     * @param save Default is false. Whether the notebook should be saved after the meta data is set.\n     * Note: This function will not wait for the save to complete, it only sends a save request.\n     * @returns The old value for the key, or undefined if it did not exist.\n     */\n    static setMetaData(notebookPanel, key, value, save = false) {\n        var _a;\n        if (!notebookPanel) {\n            throw new Error('The notebook is null or undefined. No meta data available.');\n        }\n        const oldVal = (_a = notebookPanel.model) === null || _a === void 0 ? void 0 : _a.metadata.set(key, value);\n        if (save) {\n            this.saveNotebook(notebookPanel);\n        }\n        return oldVal;\n    }\n    // /**\n    //  * Get a new Kernel, not tied to a Notebook\n    //  * Source code here: https://github.com/jupyterlab/jupyterlab/tree/473348d25bcb258ca2f0c127dd8fb5b193217135/packages/services\n    //  */\n    // public static async createNewKernel() {\n    //   // Get info about the available kernels and start a new one.\n    //   let options: Kernel.IOptions = await Kernel.getSpecs().then(kernelSpecs => {\n    //     // console.log('Default spec:', kernelSpecs.default);\n    //     // console.log('Available specs', Object.keys(kernelSpecs.kernelspecs));\n    //     // use the default name\n    //     return { name: kernelSpecs.default };\n    //   });\n    //   return await Kernel.startNew(options).then(_kernel => {\n    //     return _kernel;\n    //   });\n    // }\n    // // TODO: We can use this context manager to execute commands inside a new kernel\n    // //  and be sure that it will be disposed of at the end.\n    // //  Another approach could be to create a kale_rpc Kernel, as a singleton,\n    // //  created at startup. The only (possible) drawback is that we can not name\n    // //  a kernel instance with a custom id/name, so when refreshing JupyterLab we would\n    // //  not recognize the kernel. A solution could be to have a kernel spec dedicated to kale rpc calls.\n    // public static async executeWithNewKernel(action: Function, args: any[] = []) {\n    //   // create brand new kernel\n    //   const _k = await this.createNewKernel();\n    //   // execute action inside kernel\n    //   const res = await action(_k, ...args);\n    //   // close kernel\n    //   _k.shutdown();\n    //   // return result\n    //   return res;\n    // }\n    /**\n     * @description This function runs code directly in the notebook's kernel and then evaluates the\n     * result and returns it as a promise.\n     * @param kernel The kernel to run the code in.\n     * @param runCode The code to run in the kernel.\n     * @param userExpressions The expressions used to capture the desired info from the executed code.\n     * @param runSilent Default is false. If true, kernel will execute as quietly as possible.\n     * store_history will be set to false, and no broadcast on IOPUB channel will be made.\n     * @param storeHistory Default is false. If true, the code executed will be stored in the kernel's history\n     * and the counter which is shown in the cells will be incremented to reflect code was run.\n     * @param allowStdIn Default is false. If true, code running in kernel can prompt user for input using\n     * an input_request message.\n     * @param stopOnError Default is false. If True, does not abort the execution queue, if an exception is encountered.\n     * This allows the queued execution of multiple execute_requests, even if they generate exceptions.\n     * @returns Promise<any> - A promise containing the execution results of the code as an object with\n     * keys based on the user_expressions.\n     * @example\n     * //The code\n     * const code = \"a=123\\nb=456\\nsum=a+b\";\n     * //The user expressions\n     * const expr = {sum: \"sum\",prod: \"a*b\",args:\"[a,b,sum]\"};\n     * //Async function call (returns a promise)\n     * sendKernelRequest(notebookPanel, code, expr,false);\n     * //Result when promise resolves:\n     * {\n     *  sum:{status:\"ok\",data:{\"text/plain\":\"579\"},metadata:{}},\n     *  prod:{status:\"ok\",data:{\"text/plain\":\"56088\"},metadata:{}},\n     *  args:{status:\"ok\",data:{\"text/plain\":\"[123, 456, 579]\"}}\n     * }\n     * @see For more information on JupyterLab messages:\n     * https://jupyter-client.readthedocs.io/en/latest/messaging.html#execution-results\n     */\n    static async sendKernelRequest(kernel, runCode, userExpressions, runSilent = false, storeHistory = false, allowStdIn = false, stopOnError = false) {\n        if (!kernel) {\n            throw new Error('Kernel is null or undefined.');\n        }\n        // Wait for kernel to be ready before sending request\n        // await kernel.status;\n        const message = await kernel.requestExecute({\n            allow_stdin: allowStdIn,\n            code: runCode,\n            silent: runSilent,\n            stop_on_error: stopOnError,\n            store_history: storeHistory,\n            user_expressions: userExpressions,\n        }).done;\n        const content = message.content;\n        if (content.status !== 'ok') {\n            // If response is not 'ok', throw contents as error, log code\n            const msg = `Code caused an error:\\n${runCode}`;\n            console.error(msg);\n            if (content.traceback) {\n                content.traceback.forEach((line) => console.log(line.replace(/[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '')));\n            }\n            throw content;\n        }\n        // Return user_expressions of the content\n        return content.user_expressions;\n    }\n    /**\n     * Same as method sendKernelRequest but passing\n     * a NotebookPanel instead of a Kernel\n     */\n    static async sendKernelRequestFromNotebook(notebookPanel, runCode, userExpressions, runSilent = false, storeHistory = false, allowStdIn = false, stopOnError = false) {\n        var _a, _b, _c, _d;\n        if (!notebookPanel) {\n            throw new Error('Notebook is null or undefined.');\n        }\n        // Wait for notebook panel to be ready\n        await notebookPanel.activate;\n        await ((_a = notebookPanel.sessionContext) === null || _a === void 0 ? void 0 : _a.ready);\n        console.log('get kernel', (_b = notebookPanel.sessionContext.session) === null || _b === void 0 ? void 0 : _b.kernel);\n        return this.sendKernelRequest((_d = (_c = notebookPanel.sessionContext) === null || _c === void 0 ? void 0 : _c.session) === null || _d === void 0 ? void 0 : _d.kernel, runCode, userExpressions, runSilent, storeHistory, allowStdIn, stopOnError);\n    }\n}\n"],"names":[],"sourceRoot":""}